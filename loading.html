<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Ultimate Commercial Particle Tool</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #0A0B0C; }
        canvas { display: block; }
        #gui-container { position: absolute; top: 0; right: 0; width: 300px; }
        /* ì»¤ë¸Œ ì‹œê°í™” ìŠ¤íƒ€ì¼ */
        #curve-canvas {
            background: #222;
            border: 1px solid #444;
            margin-top: 5px;
            width: 100%;
            height: 60px;
        }
        /* Export Info */
        #export-info {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 20px;
            border-radius: 5px;
            z-index: 1000;
            display: none;
        }
    </style>
</head>
<body>
    <div id="export-info">Exporting frames... <span id="frame-count">0</span> / <span id="total-frames">0</span></div>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    
    <script src="https://unpkg.com/seedrandom@3.0.5/seedrandom.min.js"></script>
    <script src="https://unpkg.com/stats.js@0.17.0/build/stats.min.js"></script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import GUI from 'three/addons/libs/lil-gui.module.min.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- 0. ìœ í‹¸ë¦¬í‹°: Easing í•¨ìˆ˜ ë° ì‹œë“œ ì„¤ì • ---
        const Easing = {
            Linear: t => t,
            EaseInQuad: t => t * t,
            EaseOutQuad: t => t * (2 - t),
            EaseInOutSine: t => -(Math.cos(Math.PI * t) - 1) / 2,
            ElasticOut: t => {
                const c4 = (2 * Math.PI) / 3;
                return t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
            }
        };
        
        // ì‹œë“œ ì œì–´ í•¨ìˆ˜
        function applySeed(seed) {
            Math.seedrandom(seed);
        }

        // --- 1. ìœ í‹¸ë¦¬í‹°: íŒŒí‹°í´ í…ìŠ¤ì²˜ ìƒì„±ê¸° ë° ì„í¬íŠ¸ ë¡œì§ ---
        function createTexture(type, imageURL = null) {
            if (imageURL && type === 'Custom Image') {
                 // ğŸŒŸ í…ìŠ¤ì²˜ ì„í¬íŠ¸ ë¡œì§
                const loader = new THREE.TextureLoader();
                return loader.load(imageURL, (texture) => texture.needsUpdate = true);
            }
            // ê¸°ì¡´ì˜ Canvas ê¸°ë°˜ ìƒì„± ë¡œì§ (Glow, Circle, Square, Star)
            const size = 128;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            const center = size / 2;
            // ... (ê¸°ì¡´ createTexture ë‚´ë¶€ ë¡œì§ ìœ ì§€) ...
            ctx.clearRect(0, 0, size, size);
            
            if (type === 'Square') { ctx.fillStyle = '#ffffff'; ctx.fillRect(10, 10, size - 20, size - 20); } 
            else if (type === 'Circle') { ctx.beginPath(); ctx.arc(center, center, center - 10, 0, Math.PI * 2); ctx.fillStyle = '#ffffff'; ctx.fill(); } 
            else if (type === 'Glow') { 
                const grad = ctx.createRadialGradient(center, center, 0, center, center, center);
                grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
                grad.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, size, size);
            } else if (type === 'Star') {
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    ctx.lineTo(Math.cos((18 + i * 72) * Math.PI / 180) * center + center, -Math.sin((18 + i * 72) * Math.PI / 180) * center + center);
                    ctx.lineTo(Math.cos((54 + i * 72) * Math.PI / 180) * center * 0.4 + center, -Math.sin((54 + i * 72) * Math.PI / 180) * center * 0.4 + center);
                }
                ctx.closePath();
                ctx.fill();
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        // --- 2. ê¸°ë³¸ ì”¬ ë° í†µê³„ ì„¤ì • ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 60);

        const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true }); // ìº¡ì²˜ë¥¼ ìœ„í•´ preserveDrawingBuffer í™œì„±í™”
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);
        
        // ì´ˆê¸° ë¸”ë£¸ ê°•ë„ëŠ” íŒŒë¼ë¯¸í„°ì™€ ë™ê¸°í™”
        bloomPass.strength = 1.5;

        // FPS ëª¨ë‹ˆí„°ë§ (Stats.js)
        const stats = new Stats();
        stats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom
        document.body.appendChild(stats.dom);

        // --- 3. íŒŒí‹°í´ ë°ì´í„° ë° ì„¤ì • ---
        const initialParams = {
            // General & Style
            bgColor: '#050505',
            seed: Date.now().toString(), // ğŸŒŸ ëœë¤ ì‹œë“œ
            shape: 'Glow',
            customImageURL: '', // ğŸŒŸ ì»¤ìŠ¤í…€ ì´ë¯¸ì§€ URL
            count: 3000,
            size: 1.0,
            bloomStrength: 1.5,
            
            // Motion & Physics
            mode: 'Pulse',
            speed: 1.0,
            easing: 'EaseInOutSine',
            expansion: 20,
            gravity: 0.0,
            textContent: 'TEXT', // ğŸŒŸ Text ëª¨ë“œì—ì„œ ì‚¬ìš©í•  ê¸€ì
            
             // ğŸŒŸ ì½œë¦¬ì „ ì¶”ê°€
            collisionEnabled: false,
            bounceFactor: 0.5,
            
            // ğŸŒŸ í¬ê¸° ìˆ˜ëª… ì»¤ë¸Œ
            sizeCurve: 'Linear', // Linear, EaseOutQuad
            
            // ğŸŒŸ ë©€í‹° ìŠ¤í†± ìƒ‰ìƒ
            colorStop0: '#ff0055', // 0%
            colorStop1: '#7700ff', // 50%
            colorStop2: '#00ccff', // 100%

            // Export Actions
            exportGIF: () => exportAction('gif'),
            exportPNG: () => exportAction('png'),
        };

        const params = { ...initialParams }; // ê¹Šì€ ë³µì‚¬ ëŒ€ì‹  spread operator ì‚¬ìš©

        let geometry = null;
        let material = null;
        let points = null;
        let originalPositions = []; 
        let randomOffsets = []; 
        let initialRadius = []; 
        let velocities = []; 
        let particleAge = []; // ğŸŒŸ íŒŒí‹°í´ ìˆ˜ëª… ì €ì¥
        let vTargetPositions = null; // ğŸŒŸ 'V' ë° 'Text' ëª¨ë“œì—ì„œ ì‚¬ìš©í•  ëª©í‘œ í˜•íƒœ ì¢Œí‘œ
let textShapePositions = null; // ğŸŒŸ í…ìŠ¤íŠ¸ í˜•íƒœì˜ ì  êµ¬ë¦„ ì¢Œí‘œ
let alpacaShapePositions = null; // ğŸŒŸ ì•ŒíŒŒì¹´ í˜•íƒœì˜ ì  êµ¬ë¦„ ì¢Œí‘œ

        // ğŸŒŸ í…ìŠ¤íŠ¸ í˜•íƒœë¥¼ ì  êµ¬ë¦„ìœ¼ë¡œ ë³€í™˜í•˜ëŠ” í•¨ìˆ˜ (ì™¸ê³½ì„  + í¬ì†Œ ìƒ˜í”Œë§)
        function buildTextShape(text) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            // ë°°ê²½ ì´ˆê¸°í™” (ì™„ì „ íˆ¬ëª… ë°°ê²½ ìœ ì§€)
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const content = (text || 'TEXT').toString();

            // í°íŠ¸ í¬ê¸°ë¥¼ í…ìŠ¤íŠ¸ í­ì— ë§ì¶° ë™ì  ê³„ì‚°
            let fontSize = 200;
            const maxWidth = canvas.width * 0.8;
            ctx.font = `bold ${fontSize}px system-ui, -apple-system, BlinkMacSystemFont, sans-serif`;
            let metrics = ctx.measureText(content);

            while (metrics.width > maxWidth && fontSize > 40) {
                fontSize -= 10;
                ctx.font = `bold ${fontSize}px system-ui, -apple-system, BlinkMacSystemFont, sans-serif`;
                metrics = ctx.measureText(content);
            }

            // í…ìŠ¤íŠ¸ ì™¸ê³½ì„ ë§Œ ê·¸ë¦¬ê¸°
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = Math.max(4, fontSize * 0.06);
            ctx.strokeText(content, canvas.width / 2, canvas.height / 2);

            const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imgData.data;
            const positions = [];
            const step = 6; // ìƒ˜í”Œë§ ê°„ê²© (ë” ë„“ê²Œ, ì  ë°€ë„ ë‚®ì¶¤)

            for (let y = 0; y < canvas.height; y += step) {
                for (let x = 0; x < canvas.width; x += step) {
                    const idx = (y * canvas.width + x) * 4;
                    const alpha = data[idx + 3];
                    if (alpha > 128) {
                        // ë„ˆë¬´ ì¡°ë°€í•˜ê²Œ ëª¨ì´ì§€ ì•Šë„ë¡ ëœë¤ ë“œë (ë” í¬ì†Œí•˜ê²Œ)
                        if (Math.random() > 0.7) continue;

                        // ìº”ë²„ìŠ¤ ì¢Œí‘œë¥¼ ì›”ë“œ ì¢Œí‘œë¡œ ì •ê·œí™”
                        const nx = (x / canvas.width - 0.5) * 20; // X ìŠ¤ì¼€ì¼
                        const ny = (0.5 - y / canvas.height) * 10; // Y ìŠ¤ì¼€ì¼
                        positions.push(nx, ny, 0);
                    }
                }
            }

            if (positions.length > 0) {
                textShapePositions = new Float32Array(positions);
            } else {
                textShapePositions = null;
            }
        }

        // ğŸŒŸ ì•ŒíŒŒì¹´ ì‹¤ë£¨ì—£ì„ ì  êµ¬ë¦„ìœ¼ë¡œ ë³€í™˜í•˜ëŠ” í•¨ìˆ˜ (ì‹¤ë£¨ì—£ ì±„ì›€ + í¬ì†Œ ìƒ˜í”Œë§, ë ˆí¼ëŸ°ìŠ¤ ë¹„ìœ¨ì— ë§ì¶¤)
        function buildAlpacaShape() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // ë°°ê²½ ì´ˆê¸°í™” (ì™„ì „ íˆ¬ëª…)
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = '#fff';
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';

            // ì¢Œí‘œ ê¸°ì¤€:
            // - ìº”ë²„ìŠ¤ ì¤‘ì•™(256, 256)ì„ ê¸°ì¤€ìœ¼ë¡œ
            // - ë¨¸ë¦¬ëŠ” ì™¼ìª½, ê¼¬ë¦¬ëŠ” ì˜¤ë¥¸ìª½
            // - í° ë‘¥ê·¼ ëª¸ + ì§§ì€ ë‹¤ë¦¬ + í° ë¨¸ë¦¬ + ë™ê·¸ë€ ê¼¬ë¦¬

            // --- ëª¸í†µ: í° íƒ€ì›í˜• (í†µí†µí•œ ë°”ë””) ---
            ctx.beginPath();
            ctx.ellipse(260, 320, 140, 120, 0, 0, Math.PI * 2);
            ctx.fill();

            // --- ê¼¬ë¦¬: ëª¸í†µ ì˜¤ë¥¸ìª½ ë’¤ì˜ ë‘¥ê·¼ ì†œë­‰ì¹˜ ---
            ctx.beginPath();
            ctx.ellipse(380, 300, 40, 40, 0, 0, Math.PI * 2);
            ctx.fill();

            // --- ëª©: ëª¸í†µ ìœ„ì—ì„œ ë¨¸ë¦¬ê¹Œì§€ ì´ì–´ì§€ëŠ” êµµì€ ê¸°ë‘¥ ---
            ctx.beginPath();
            ctx.moveTo(220, 260);
            ctx.lineTo(260, 260);
            ctx.lineTo(260, 190);
            ctx.lineTo(230, 190);
            ctx.closePath();
            ctx.fill();

            // --- ë¨¸ë¦¬: í° ë‘¥ê·¼ ì–¼êµ´ (ì„¸ë¡œë¡œ ì‚´ì§ ê¸´ íƒ€ì›) ---
            ctx.beginPath();
            ctx.ellipse(210, 190, 70, 65, 0, 0, Math.PI * 2);
            ctx.fill();

            // --- ì•ë¨¸ë¦¬(ë³µìŠ¬ë³µìŠ¬ í„¸) : ë¨¸ë¦¬ ìœ—ë¶€ë¶„ì„ ë¬¼ê²° í˜•íƒœë¡œ ë®ëŠ” ë ˆì´ì–´ ---
            ctx.beginPath();
            ctx.moveTo(150, 160);
            ctx.quadraticCurveTo(180, 140, 205, 150);
            ctx.quadraticCurveTo(230, 140, 255, 155);
            ctx.quadraticCurveTo(270, 150, 275, 170);
            ctx.lineTo(275, 200);
            ctx.lineTo(150, 200);
            ctx.closePath();
            ctx.fill();

            // --- ì£¼ë‘¥ì´: ì™¼ìª½ ë°©í–¥ìœ¼ë¡œ ì‚´ì§ ëŒì¶œëœ ë‘¥ê·¼ ë¶€ë¶„ ---
            ctx.beginPath();
            ctx.ellipse(150, 195, 28, 24, 0, 0, Math.PI * 2);
            ctx.fill();

            // --- ê·€: ìœ„ë¡œ ê¸¸ê²Œ ì†Ÿì€ ë‘ ê°œì˜ ê·€ ---
            // ì™¼ìª½ ê·€
            ctx.beginPath();
            ctx.moveTo(195, 135);
            ctx.lineTo(190, 100);
            ctx.lineTo(205, 130);
            ctx.closePath();
            ctx.fill();

            // ì˜¤ë¥¸ìª½ ê·€
            ctx.beginPath();
            ctx.moveTo(230, 138);
            ctx.lineTo(235, 100);
            ctx.lineTo(245, 135);
            ctx.closePath();
            ctx.fill();

            // --- ë‹¤ë¦¬: ì§§ê³  í†µí†µí•œ ë„¤ ë‹¤ë¦¬ ---
            const legWidth = 32;
            const legHeight = 170; // ê¸°ì¡´ 85ì—ì„œ 2ë°°ë¡œ ëŠ˜ë¦¼
            const legTopY = 360;
            // ì•ë‹¤ë¦¬(ì™¼ìª½), ë’·ë‹¤ë¦¬(ì˜¤ë¥¸ìª½) ì‚¬ì´ ê°„ê²©ì„ ë” ë²Œë¦° ì¢Œí‘œ
            const legXs = [230, 265, 325, 360];

            for (let i = 0; i < legXs.length; i++) {
                const x = legXs[i];
                const offset = (i % 2 === 0) ? 0 : 3; // ì•½ê°„ì˜ ê¹Šì´ê° ì°¨ì´
                ctx.beginPath();
                if (ctx.roundRect) {
                    ctx.roundRect(x - legWidth / 2, legTopY + offset, legWidth, legHeight, 12);
                } else {
                    // roundRect ë¯¸ì§€ì› ë¸Œë¼ìš°ì € fallback
                    ctx.rect(x - legWidth / 2, legTopY + offset, legWidth, legHeight);
                }
                ctx.fill();
            }

            // --- ì‹¤ë£¨ì—£ì—ì„œ ì  ìƒ˜í”Œë§ ---
            const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imgData.data;
            const positions = [];
            const step = 4;      // ìƒ˜í”Œë§ ê°„ê²© (ì¡°ê¸ˆ ì´˜ì´˜í•˜ê²Œ)
            const dropRate = 0.5; // ëœë¤ ë“œë ë¹„ìœ¨ (1ì— ê°€ê¹Œìš¸ìˆ˜ë¡ í¬ì†Œ)

            for (let y = 0; y < canvas.height; y += step) {
                for (let x = 0; x < canvas.width; x += step) {
                    const idx = (y * canvas.width + x) * 4;
                    const alpha = data[idx + 3];
                    if (alpha > 128) {
                        if (Math.random() > dropRate) continue;

                        // ìº”ë²„ìŠ¤ ì¢Œí‘œë¥¼ ì›”ë“œ ì¢Œí‘œë¡œ ì •ê·œí™”
                        const nx = (x / canvas.width - 0.5) * 18;
                        const ny = (0.5 - y / canvas.height) * 18;
                        positions.push(nx, ny, 0);
                    }
                }
            }

            if (positions.length > 0) {
                alpacaShapePositions = new Float32Array(positions);
            } else {
                alpacaShapePositions = null;
            }
        }

        function generateParticles() {
            applySeed(params.seed); // ğŸŒŸ ì‹œë“œ ì ìš©
            
            if (points) {
                geometry.dispose();
                material.dispose();
                scene.remove(points);
            }

            geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(params.count * 3);
            const colors = new Float32Array(params.count * 3);
            
            originalPositions = new Float32Array(params.count * 3);
            randomOffsets = new Float32Array(params.count);
            initialRadius = new Float32Array(params.count);
            velocities = [];
            particleAge = new Float32Array(params.count);
            vTargetPositions = new Float32Array(params.count * 3);
            // ğŸŒŸ í…ìŠ¤íŠ¸ í˜•íƒœ ì  êµ¬ë¦„ ì¤€ë¹„
            buildTextShape(params.textContent);
            // ğŸŒŸ ì•ŒíŒŒì¹´ í˜•íƒœ ì  êµ¬ë¦„ ì¤€ë¹„
            buildAlpacaShape();

        for (let i = 0; i < params.count; i++) {
            const i3 = i * 3;
            
            // ì´ˆê¸° ìœ„ì¹˜ ì„¤ì • (Pulse/Wave ëª¨ë“œë¥¼ ìœ„í•´ êµ¬í˜• ë¶„í¬ ìœ ì§€)
            const r = Math.random() * 15; 
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);

            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta);
            const z = r * Math.cos(phi);

            positions[i3] = x;
            positions[i3 + 1] = y;
            positions[i3 + 2] = z;

            originalPositions[i3] = x;
            originalPositions[i3 + 1] = y;
            originalPositions[i3 + 2] = z;

            randomOffsets[i] = Math.random();
            initialRadius[i] = r; 
            velocities.push({ x: 0, y: 0, z: 0 });
            particleAge[i] = Math.random(); // ğŸŒŸ ì´ˆê¸° ìˆ˜ëª… ëœë¤ ì„¤ì • (0~1)

            // ğŸŒŸ 'V' / 'Text' / 'Alpaca' ëª¨ë“œì—ì„œ ì‚¬ìš©í•  ëª©í‘œ ì¢Œí‘œ
            if (params.mode === 'Text' && textShapePositions && textShapePositions.length >= 3) {
                // í…ìŠ¤íŠ¸ ì  êµ¬ë¦„ì—ì„œ ìˆœí™˜ ìƒ˜í”Œë§
                const idx = (i3 % textShapePositions.length);
                vTargetPositions[i3]     = textShapePositions[idx];
                vTargetPositions[i3 + 1] = textShapePositions[idx + 1];
                vTargetPositions[i3 + 2] = textShapePositions[idx + 2];
            } else if (params.mode === 'Alpaca' && alpacaShapePositions && alpacaShapePositions.length >= 3) {
                // ì•ŒíŒŒì¹´ ì  êµ¬ë¦„ì—ì„œ ìˆœí™˜ ìƒ˜í”Œë§
                const idx = (i3 % alpacaShapePositions.length);
                vTargetPositions[i3]     = alpacaShapePositions[idx];
                vTargetPositions[i3 + 1] = alpacaShapePositions[idx + 1];
                vTargetPositions[i3 + 2] = alpacaShapePositions[idx + 2];
            } else {
                // ê¸°ë³¸ V ëª¨ë“œìš©: ì¤‘ì‹¬ ê·¼ì²˜ì˜ ëœë¤ í˜•íƒœ
                const vr = Math.random() * 5; 
                const vTheta = Math.random() * Math.PI * 2;
                const vPhi = Math.acos((Math.random() * 2) - 1);
                const vx = vr * Math.sin(vPhi) * Math.cos(vTheta);
                const vy = vr * Math.sin(vPhi) * Math.sin(vTheta);
                const vz = vr * Math.cos(vPhi);
                vTargetPositions[i3] = vx;
                vTargetPositions[i3 + 1] = vy;
                vTargetPositions[i3 + 2] = vz;
            }
        }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const texture = createTexture(params.shape, params.customImageURL);

            material = new THREE.PointsMaterial({
                size: params.size,
                map: texture,
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            points = new THREE.Points(geometry, material);
            scene.add(points);
        }

        // --- 4. GUI ë° ì»¤ë¸Œ ì‹œê°í™” ---
        const gui = new GUI({ title: 'Ultimate AI Loading Tool' });
        const controllers = []; // ğŸŒŸ íŒŒë¼ë¯¸í„° ì»¨íŠ¸ë¡¤ëŸ¬ë“¤ì„ ëª¨ì•„ì„œ í”„ë¦¬ì…‹ ë¡œë“œ í›„ updateDisplayìš©ìœ¼ë¡œ ì‚¬ìš©

        // ğŸŒŸ í”„ë¦¬ì…‹ ê¸°ëŠ¥ (JSON íŒŒì¼ ê¸°ë°˜ Export/Import)
        const presetActions = {
            save: () => {
                const presetName = prompt("í”„ë¦¬ì…‹ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš” (íŒŒì¼ëª…ìœ¼ë¡œ ì‚¬ìš©ë©ë‹ˆë‹¤):", "MyPreset");
                const fileName = presetName && presetName.trim().length > 0 ? presetName.trim() : 'particlePreset';
                const data = JSON.stringify(params, null, 2);
                const blob = new Blob([data], { type: 'application/json' });
                const url = URL.createObjectURL(blob);

                const link = document.createElement('a');
                link.href = url;
                link.download = `${fileName}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);

                alert(`í”„ë¦¬ì…‹ì´ '${fileName}.json' íŒŒì¼ë¡œ ë‚´ë³´ë‚´ì¡ŒìŠµë‹ˆë‹¤.`);
            },
            load: () => {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'application/json';

                input.onchange = (e) => {
                    const file = e.target.files && e.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        try {
                            const loadedParams = JSON.parse(ev.target.result);
                            // params ê°ì²´ì— ë¡œë“œí•œ ê°’ ë®ì–´ì“°ê¸°
                            Object.assign(params, loadedParams);

                            // ì¦‰ì‹œ ë°˜ì˜ì´ í•„ìš”í•œ ê²ƒë“¤ ì ìš©
                            scene.background = new THREE.Color(params.bgColor);
                            bloomPass.strength = params.bloomStrength;

                            // íŒŒí‹°í´ ì¬ìƒì„±
                            generateParticles();

                            // ğŸŒŸ GUI ì»¨íŠ¸ë¡¤ëŸ¬ë“¤ ê°’ ê°±ì‹  (ìŠ¬ë¼ì´ë”/ì»¬ëŸ¬ í”¼ì»¤ ê°’ì„ í˜„ì¬ paramsë¡œ ë™ê¸°í™”)
                            controllers.forEach(ctrl => ctrl.updateDisplay());

                            alert("í”„ë¦¬ì…‹ JSONì´ ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.");
                        } catch (err) {
                            console.error(err);
                            alert("í”„ë¦¬ì…‹ JSONì„ ì½ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì˜¬ë°”ë¥¸ í˜•ì‹ì¸ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.");
                        }
                    };
                    reader.readAsText(file, 'utf-8');
                };

                input.click();
            }
        };

        let setupGUI;

        setupGUI = () => {
            // ì´ˆê¸° ë°°ê²½ìƒ‰ ì„¤ì • (scene.backgroundê°€ nullì¸ ìƒíƒœì—ì„œ setì„ í˜¸ì¶œí•˜ì§€ ì•Šë„ë¡ ë°©ì§€)
            scene.background = new THREE.Color(params.bgColor);
            
            const generalFolder = gui.addFolder('General (ì¼ë°˜)');
            const bgCtrl = generalFolder.addColor(params, 'bgColor').name('ë°°ê²½ìƒ‰').onChange(v => {
                scene.background = new THREE.Color(v);
            });
            controllers.push(bgCtrl);

            const seedCtrl = generalFolder.add(params, 'seed').name('ëœë¤ ì‹œë“œ').onFinishChange(generateParticles);
            controllers.push(seedCtrl);

            const countCtrl = generalFolder.add(params, 'count', 500, 10000, 100).name('íŒŒí‹°í´ ìˆ˜').onFinishChange(generateParticles);
            controllers.push(countCtrl);

            const sizeCtrl = generalFolder.add(params, 'size', 0.1, 5).name('ê¸°ë³¸ í¬ê¸°').onChange(v => material.size = v);
            controllers.push(sizeCtrl);

            const bloomCtrl = generalFolder.add(params, 'bloomStrength', 0, 3).name('ë¸”ë£¸ ê°•ë„').onChange(v => bloomPass.strength = v);
            controllers.push(bloomCtrl);

            const shapeFolder = gui.addFolder('Shape (ëª¨ì–‘)');
            const shapeCtrl = shapeFolder.add(params, 'shape', ['Glow', 'Circle', 'Square', 'Star', 'Custom Image']).name('íŒŒí‹°í´ ëª¨ì–‘').onChange(v => {
                if(v === 'Custom Image') {
                    // ğŸŒŸ í…ìŠ¤ì²˜ ì—…ë¡œë“œ UI
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = 'image/*';
                    input.onchange = (e) => {
                        const file = e.target.files[0];
                        if (file) {
                            params.customImageURL = URL.createObjectURL(file);
                            generateParticles();
                        }
                    };
                    input.click();
                } else {
                    params.customImageURL = '';
                    generateParticles();
                }
            });
            controllers.push(shapeCtrl);

            // ğŸŒŸ ìƒ‰ìƒ ìˆ˜ëª… ê·¸ë¼ë””ì–¸íŠ¸
            const colorFolder = gui.addFolder('Color Over Lifetime');
            const c0Ctrl = colorFolder.addColor(params, 'colorStop0').name('Stop 0% (Start)').onFinishChange(generateParticles);
            const c1Ctrl = colorFolder.addColor(params, 'colorStop1').name('Stop 50% (Mid)').onFinishChange(generateParticles);
            const c2Ctrl = colorFolder.addColor(params, 'colorStop2').name('Stop 100% (End)').onFinishChange(generateParticles);
            controllers.push(c0Ctrl, c1Ctrl, c2Ctrl);

            // ğŸŒŸ í¬ê¸° ìˆ˜ëª… ì»¤ë¸Œ
            const sizeLifeFolder = gui.addFolder('Size Over Lifetime');
            const sizeCurveCtrl = sizeLifeFolder.add(params, 'sizeCurve', Object.keys(Easing)).name('í¬ê¸° ì»¤ë¸Œ').onChange(drawCurve.bind(null, 'size'));
            controllers.push(sizeCurveCtrl);
            
            // ğŸŒŸ í¬ê¸° ì»¤ë¸Œ ì‹œê°í™” ìº”ë²„ìŠ¤ ì¶”ê°€
            const sizeCanvasContainer = document.createElement('div');
            const sizeCurveCanvas = document.createElement('canvas');
            sizeCurveCanvas.width = 250;
            sizeCurveCanvas.height = 60;
            sizeCurveCanvas.style.cssText = '#curve-canvas';
            sizeLifeFolder.domElement.appendChild(sizeCurveCanvas);

            // ğŸŒŸ ë¬¼ë¦¬ ë° ëª¨ì…˜
            const motionFolder = gui.addFolder('Motion & Physics');
            let textController; // Text ëª¨ë“œ ì „ìš© ì»¨íŠ¸ë¡¤ëŸ¬

            const modeController = motionFolder
                .add(params, 'mode', ['Pulse', 'Flow', 'Ring Wave', 'Vortex', 'Explosion', 'Swirl', 'Fireflies', 'V', 'Text', 'Alpaca', 'Motion1'])
                .name('ë™ì‘ ëª¨ë“œ')
                .onChange((value) => {
                    if (textController) {
                        if (value === 'Text') {
                            textController.show();
                        } else {
                            textController.hide();
                        }
                    }
                    generateParticles();
                });
            controllers.push(modeController);

            const speedCtrl = motionFolder.add(params, 'speed', 0.1, 5).name('ì¬ìƒ ì†ë„');
            controllers.push(speedCtrl);

            const expansionCtrl = motionFolder.add(params, 'expansion', 0, 50).name('í¼ì§ ë²”ìœ„');
            controllers.push(expansionCtrl);

            const gravityCtrl = motionFolder.add(params, 'gravity', -0.5, 0.5).name('ì¤‘ë ¥ ê°•ë„');
            controllers.push(gravityCtrl);
            
            const collisionCtrl = motionFolder.add(params, 'collisionEnabled').name('ì½œë¦¬ì „(ë°”ë‹¥ ì¶©ëŒ)');
            controllers.push(collisionCtrl);

            const bounceCtrl = motionFolder.add(params, 'bounceFactor', 0, 1).name('ë°˜ë°œ ê³„ìˆ˜').listen(); // 0: í¡ìˆ˜, 1: ì™„ë²½ ë°˜ë°œ
            controllers.push(bounceCtrl);

            textController = motionFolder.add(params, 'textContent').name('Text ë‚´ìš© (Text ëª¨ë“œ ì „ìš©)').onFinishChange(() => {
                if (params.mode === 'Text') {
                    generateParticles();
                }
            });
            controllers.push(textController);

            // ì´ˆê¸° ëª¨ë“œê°€ Textê°€ ì•„ë‹ ê²½ìš° Text ì…ë ¥ í•„ë“œ ìˆ¨ê¹€
            if (params.mode !== 'Text') {
                textController.hide();
            }

            // ğŸŒŸ ê°€ì†ë„ ì»¤ë¸Œ
            const easingCanvasContainer = document.createElement('div');
            const easingCurveCanvas = document.createElement('canvas');
            easingCurveCanvas.width = 250;
            easingCurveCanvas.height = 60;
            easingCurveCanvas.style.cssText = '#curve-canvas';
            motionFolder.domElement.appendChild(easingCurveCanvas);
            const easingCtrl = motionFolder.add(params, 'easing', Object.keys(Easing)).name('ê°€ì†ë„ ì»¤ë¸Œ').onChange(drawCurve.bind(null, 'easing'));
            controllers.push(easingCtrl);
            
            // ğŸŒŸ Export ê¸°ëŠ¥
            const exportFolder = gui.addFolder('Export (ì¶œë ¥)');
            exportFolder.add(params, 'exportGIF').name('Export GIF (Sequence)');
            exportFolder.add(params, 'exportPNG').name('Export PNG Sequence');

            // ğŸŒŸ í”„ë¦¬ì…‹ ë²„íŠ¼
            const presetFolder = gui.addFolder('Presets');
            presetFolder.add(presetActions, 'save').name('ğŸ’¾ Save Preset');
            presetFolder.add(presetActions, 'load').name('ğŸ“‚ Load Preset');

            // ì»¤ë¸Œ ê·¸ë¦¬ê¸° í•¨ìˆ˜ ì •ì˜
            function drawCurve(type, value) {
                const canvas = type === 'size' ? sizeCurveCanvas : easingCurveCanvas;
                const ctx = canvas.getContext('2d');
                const w = canvas.width;
                const h = canvas.height;
                const func = Easing[type === 'size' ? params.sizeCurve : params.easing];

                ctx.fillStyle = '#222';
                ctx.fillRect(0, 0, w, h);
                
                ctx.beginPath();
                ctx.strokeStyle = type === 'size' ? '#ffa500' : '#00ffea';
                ctx.lineWidth = 2;

                for (let i = 0; i <= w; i++) {
                    const t = i / w;
                    const val = func(t);
                    const y = h - (val * h * 0.8 + h * 0.1); 
                    
                    if (i === 0) ctx.moveTo(i, y);
                    else ctx.lineTo(i, y);
                }
                ctx.stroke();
            }

            drawCurve('size');
            drawCurve('easing');
        };
        
        setupGUI();
        generateParticles();


        // --- 5. ì• ë‹ˆë©”ì´ì…˜ ë° ë¬¼ë¦¬ ì—”ì§„ ë¡œì§ ---
        const clock = new THREE.Clock();
        const MAX_AGE = 1.0; // íŒŒí‹°í´ ìˆ˜ëª…ì˜ ê¸°ì¤€

        // ğŸŒŸ Export ë³€ìˆ˜
        let isExporting = false;
        let framesToCapture = 0;
        let capturedFrames = 0;
        let exportFormat = 'png';
        const exportInfoElement = document.getElementById('export-info');
        const frameCountElement = document.getElementById('frame-count');
        const totalFramesElement = document.getElementById('total-frames');

        function exportAction(format) {
            exportFormat = format;
            framesToCapture = 60 * 3; // 3ì´ˆ (180í”„ë ˆì„)
            capturedFrames = 0;
            isExporting = true;
            
            totalFramesElement.textContent = framesToCapture;
            exportInfoElement.style.display = 'block';

            // GIF ë¼ì´ë¸ŒëŸ¬ë¦¬ ì—°ë™ (ì‹¤ì œ êµ¬í˜„ì€ ìƒëµí•˜ê³  ì½˜ì†” ë¡œê·¸ë¡œ ëŒ€ì²´)
            if (format === 'gif') {
                console.log("GIF Export: In a production environment, this would start the gif.js worker.");
                // ì˜ˆ: gif = new GIF({ workers: 2, quality: 10 }); 
            }
        }

        function downloadFrame(frame) {
            const link = document.createElement('a');
            link.download = `particle_frame_${frame}.png`;
            link.href = renderer.domElement.toDataURL('image/png');
            link.click();
        }

        function animate() {
            stats.begin(); // FPS ì¸¡ì • ì‹œì‘

            requestAnimationFrame(animate);
            // ì§€ì˜¤ë©”íŠ¸ë¦¬/ë¨¸í‹°ë¦¬ì–¼ì´ ì¤€ë¹„ë˜ì§€ ì•Šì•˜ë‹¤ë©´ ë Œë”ë§ì„ ì‹œë„í•˜ì§€ ì•ŠìŒ
            if (!geometry || !material || !points) {
                controls.update();
                composer.render();
                stats.end();
                return;
            }
            const time = clock.getElapsedTime();
            const dt = clock.getDelta(); 

            // ğŸŒŸ ê¸°ë³¸ì ìœ¼ë¡œ í¬ì¸íŠ¸ ì „ì²´ ìŠ¤ì¼€ì¼ì€ 1ë¡œ ìœ ì§€ (Motion1ì—ì„œë§Œ ë”°ë¡œ ì¡°ì •)
            points.scale.set(1, 1, 1);
            const positions = geometry.attributes.position.array;
            const colors = geometry.attributes.color.array;
            
            const sizeFunc = Easing[params.sizeCurve];

            // ğŸŒŸ ëª¨ë“  íŒŒí‹°í´ ì—…ë°ì´íŠ¸
            for (let i = 0; i < params.count; i++) {
                const i3 = i * 3;
                
                // --- A. ìˆ˜ëª… ì—…ë°ì´íŠ¸ ë° ìƒ‰ìƒ/í¬ê¸° ë³€ê²½ ---
                if (params.mode === 'Flow' || params.mode === 'Vortex') {
                    particleAge[i] += dt / MAX_AGE; // ìˆ˜ëª… ì¦ê°€
                    if (positions[i3 + 1] > 20 || positions[i3 + 1] < -20) { // ê²½ê³„ ë„ë‹¬ ì‹œ ë¦¬ì…‹
                         particleAge[i] = 0;
                    }
                } else {
                    // Pulse/Wave ê³„ì—´ ëª¨ë“œëŠ” ì‹œê°„ ê¸°ë°˜ìœ¼ë¡œ ê³µí†µ ìˆ˜ëª… ê°’ì„ ì‚¬ìš©
                    particleAge[i] = (Math.sin(time * params.speed) + 1) / 2; // 0~1 ì§„ë™
                }

                // ë„ˆë¬´ ì–´ë‘¡ê±°ë‚˜ ë„ˆë¬´ ë°ì€ ê·¹ë‹¨ì„ í”¼í•˜ê¸° ìœ„í•´ 0.2 ~ 0.8 ë²”ìœ„ë¡œ ì¬ë§¤í•‘
                const rawAge = Math.min(particleAge[i], 1.0);
                const ageRatio = 0.2 + 0.6 * rawAge; // 0.2 ~ 0.8

                if (params.mode === 'Motion1') {
                    // ğŸŒŸ Motion1ì—ì„œëŠ” íŒŒí‹°í´ í¬ê¸°ë¥¼ ê³ ì •í•˜ê³ , ì „ì²´ ìŠ¤ì¼€ì¼ë§Œ ë”°ë¡œ ì¡°ì •
                    material.size = params.size;
                } else {
                    // ğŸŒŸ Size Over Lifetime (ë‹¤ë¥¸ ëª¨ë“œìš©)
                    const baseSizeFactor = 1.1 - sizeFunc(ageRatio); // ìˆ˜ëª…ì— ë”°ë¥¸ ê¸°ë³¸ í¬ê¸° ë³€í™”
                    const pulseAmp = 0.15;   // â† ì¼ë°˜ ëª¨ë“œìš© ì§„í­
                    const pulseFreq = 2.0;   // â† ì¼ë°˜ ëª¨ë“œìš© ì†ë„
                    const pulse = 1 + pulseAmp * Math.sin(time * params.speed * pulseFreq); // ì‹œê°„ ê¸°ë°˜ í„ìŠ¤

                    material.size = params.size * baseSizeFactor * pulse;
                }

                // ğŸŒŸ Color Over Lifetime (ë©€í‹° ìŠ¤í†± ê·¸ë¼ë””ì–¸íŠ¸)
                const c0 = new THREE.Color(params.colorStop0);
                const c1 = new THREE.Color(params.colorStop1);
                const c2 = new THREE.Color(params.colorStop2);
                let finalColor = new THREE.Color();
                
                if (ageRatio <= 0.5) {
                    finalColor.copy(c0).lerp(c1, ageRatio * 2); // 0%~50%
                } else {
                    finalColor.copy(c1).lerp(c2, (ageRatio - 0.5) * 2); // 50%~100%
                }
                colors[i3] = finalColor.r;
                colors[i3 + 1] = finalColor.g;
                colors[i3 + 2] = finalColor.b;


                // --- B. ë¬¼ë¦¬ ë° ìœ„ì¹˜ ì—…ë°ì´íŠ¸ (Flow, Vortex) ---
                if (params.mode === 'Flow' || params.mode === 'Vortex') {
                    
                    // ì¤‘ë ¥ ì ìš©
                    velocities[i].y -= params.gravity * dt * 5;

                    if (params.mode === 'Flow') {
                        positions[i3 + 1] += velocities[i].y * params.speed + (0.02 * params.speed); 
                        
                    } else if (params.mode === 'Vortex') {
                        // ... (ê¸°ì¡´ Vortex ë¡œì§ ìœ ì§€) ...
                        const rotationSpeed = 0.05 * params.speed;
                        let x = positions[i3];
                        let z = positions[i3 + 2];
                        const angle = Math.atan2(z, x);
                        const r = Math.sqrt(x*x + z*z);
                        const newAngle = angle + rotationSpeed * dt * 10; 
                        positions[i3] = r * Math.cos(newAngle);
                        positions[i3 + 2] = r * Math.sin(newAngle);
                        positions[i3 + 1] += (velocities[i].y + 0.5) * dt * params.speed; 
                    }

                    // ğŸŒŸ ì½œë¦¬ì „ ê°ì§€ ë° ë°˜ë°œ (ë°”ë‹¥)
                    if (params.collisionEnabled && positions[i3 + 1] < -20) { // ë°”ë‹¥ Y=-20
                        positions[i3 + 1] = -20; // ìœ„ì¹˜ ê³ ì •
                        velocities[i].y *= -params.bounceFactor; // ë°˜ë°œ
                        // ë¯¸ì„¸í•œ Yì¶• ì†ë„ ì¦ê°€ë¡œ ë¼ì„ ë°©ì§€
                        if (velocities[i].y < 0.1) velocities[i].y = 0.1;
                    }

                    // ê²½ê³„ ì¬ì„¤ì • (ìˆœí™˜)
                    const boundaryY = 20;
                    if (positions[i3 + 1] > boundaryY) {
                         positions[i3 + 1] = -boundaryY; 
                         velocities[i].y = 0; 
                         particleAge[i] = 0;
                    } else if (positions[i3 + 1] < -boundaryY) {
                         positions[i3 + 1] = boundaryY;
                         velocities[i].y = 0; 
                         particleAge[i] = 0;
                    }
                }
            }
            
            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true; // ìƒ‰ìƒ ì—…ë°ì´íŠ¸ í™œì„±í™”

        // --- C. Pulse/Wave ëª¨ë“œ (ì‹œê°„ ê¸°ë°˜ ì• ë‹ˆë©”ì´ì…˜) ---
        if (params.mode === 'Pulse') {
            const rawTime = (Math.sin(time * params.speed) + 1) / 2; 
            const easeVal = Easing[params.easing](rawTime); 
            for (let i = 0; i < params.count; i++) {
                const i3 = i * 3;
                const expansionFactor = 1 + (easeVal * params.expansion * 0.1) + (Math.sin(time * 2 + randomOffsets[i]) * 0.1);
                positions[i3] = originalPositions[i3] * expansionFactor;
                positions[i3 + 1] = originalPositions[i3 + 1] * expansionFactor;
                positions[i3 + 2] = originalPositions[i3 + 2] * expansionFactor;
            }
        } else if (params.mode === 'Ring Wave') {
             // ... (ê¸°ì¡´ Ring Wave ë¡œì§ ìœ ì§€) ...
            for (let i = 0; i < params.count; i++) {
                const i3 = i * 3;
                const radius = initialRadius[i];
                const waveTime = (time * params.speed * 0.5) - (radius * 0.2) + randomOffsets[i];
                const waveFactor = 1 + (Math.sin(waveTime) * params.expansion * 0.05);
                positions[i3] = originalPositions[i3] * waveFactor;
                positions[i3 + 2] = originalPositions[i3 + 2] * waveFactor;
                positions[i3 + 1] = originalPositions[i3 + 1];
            }
        } else if (params.mode === 'Explosion') {
            for (let i = 0; i < params.count; i++) {
                const i3 = i * 3;
                const intensity = params.expansion * 0.3;
                positions[i3] += (originalPositions[i3] * 0.02) * intensity;
                positions[i3 + 1] += (originalPositions[i3 + 1] * 0.02) * intensity;
                positions[i3 + 2] += (originalPositions[i3 + 2] * 0.02) * intensity;
            }
        } else if (params.mode === 'Swirl') {
            const swirlSpeed = params.speed * 0.5;
            for (let i = 0; i < params.count; i++) {
                const i3 = i * 3;
                const x = positions[i3];
                const z = positions[i3 + 2];
                const angle = Math.atan2(z, x) + swirlSpeed * dt;
                const r = Math.sqrt(x*x + z*z);
                positions[i3] = r * Math.cos(angle);
                positions[i3 + 2] = r * Math.sin(angle);
                positions[i3 + 1] += Math.sin(time * 2 + randomOffsets[i]) * 0.02;
            }
        } else if (params.mode === 'Fireflies') {
            for (let i = 0; i < params.count; i++) {
                const i3 = i * 3;
                positions[i3] += (Math.sin(time * 3 + randomOffsets[i]) * 0.02) * params.speed;
                positions[i3 + 1] += (Math.cos(time * 4 + randomOffsets[i]) * 0.02) * params.speed;
                positions[i3 + 2] += (Math.sin(time * 5 + randomOffsets[i]) * 0.02) * params.speed;
            }
        } else if (params.mode === 'Motion1') {
            // ğŸŒŸ Motion1 ëª¨ë“œ: êµ¬ í˜•íƒœë¥¼ ìœ ì§€í•œ ì±„ Yì¶•ì„ ì¤‘ì‹¬ìœ¼ë¡œ ê³µì „
            //    + ì „ì²´ í¬ì¸íŠ¸ ì˜¤ë¸Œì íŠ¸ ìŠ¤ì¼€ì¼ë¡œ ì»¤ì¡Œë‹¤/ì‘ì•„ì¡Œë‹¤ êµ¬í˜„
            const angularSpeed = params.speed * 0.6; // íšŒì „ ì†ë„

            // ì „ì²´ ìŠ¤ì¼€ì¼ í„ìŠ¤ (êµ¬ ë°˜ê²½ì´ ì»¤ì¡Œë‹¤/ì‘ì•„ì¡Œë‹¤)
            const scalePulseAmp = 0.18;     // ì „ì²´ í¬ê¸° ë³€í™” ì§„í­ (ì¡°ì ˆ í¬ì¸íŠ¸ â‘ ) glenn1
            const scalePulseFreq = 1.88;     // í˜¸í¡ ì†ë„ (ì¡°ì ˆ í¬ì¸íŠ¸ â‘¡) glenn2
            const scale = 1 + scalePulseAmp * Math.sin(time * params.speed * scalePulseFreq);

            for (let i = 0; i < params.count; i++) {
                const i3 = i * 3;

                const ox = originalPositions[i3];
                const oy = originalPositions[i3 + 1];
                const oz = originalPositions[i3 + 2];

                // XZ í‰ë©´ì—ì„œì˜ ë°˜ì§€ë¦„ ë° ì´ˆê¸° ê°ë„
                const r = Math.sqrt(ox * ox + oz * oz) || 0.0001;
                const baseAngle = Math.atan2(oz, ox);
                const angle = baseAngle + time * angularSpeed;

                // íšŒì „ ê¶¤ë„ (êµ¬ í˜•íƒœ ìœ ì§€) - ê°œë³„ íŒŒí‹°í´ì€ í•­ìƒ ê°™ì€ êµ¬ ê¶¤ë„ ìœ„ë¥¼ ê³µì „
                positions[i3]     = r * Math.cos(angle);
                positions[i3 + 2] = r * Math.sin(angle);

                // YëŠ” ì›ë˜ ë†’ì´ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì•½ê°„ì˜ ìœ„/ì•„ë˜ ì§„ë™ë§Œ ì ìš©
                const bobbing = Math.sin(time * params.speed + randomOffsets[i] * Math.PI * 2) * 0.5;
                positions[i3 + 1] = oy + bobbing;
            }

            // ğŸŒŸ ì „ì²´ ì˜¤ë¸Œì íŠ¸ ìŠ¤ì¼€ì¼ë¡œë§Œ ì»¤ì¡Œë‹¤/ì‘ì•„ì¡Œë‹¤ í‘œí˜„
            points.scale.set(scale, scale, scale);
        } else if (params.mode === 'V' || params.mode === 'Text' || params.mode === 'Alpaca') {
            // ğŸŒŸ 'V' / 'Text' / 'Alpaca' ëª¨ë“œ: ëœë¤í•˜ê²Œ í©ì–´ì¡Œë‹¤ê°€ ì¤‘ì‹¬ ê·¼ì²˜ì˜ í˜•íƒœ(ëœë¤/í…ìŠ¤íŠ¸/ì•ŒíŒŒì¹´)ë¡œ ëª¨ì´ëŠ” ëª¨ì…˜
            // 0 ~ 1 ~ 0ìœ¼ë¡œ ë°˜ë³µë˜ëŠ” ì‚¼ê°íŒŒ ê¸°ë°˜ì˜ ë³´ê°„ ê³„ìˆ˜
            const cycleDuration = 4.0; // í•œ ì£¼ê¸°(í©ì–´ì§ â†’ ëª¨ì„ â†’ í©ì–´ì§) ì‹œê°„
            const phase = (time * params.speed) % cycleDuration;
            const halfCycle = cycleDuration * 0.5;
            const rawT = phase < halfCycle ? (phase / halfCycle) : (2 - phase / halfCycle); // 0â†’1â†’0
            const easedT = Easing[params.easing](Math.min(Math.max(rawT, 0), 1));
            const invT = 1 - easedT;

            for (let i = 0; i < params.count; i++) {
                const i3 = i * 3;

                const sx = originalPositions[i3];
                const sy = originalPositions[i3 + 1];
                const sz = originalPositions[i3 + 2];

                const tx = vTargetPositions ? vTargetPositions[i3] : 0;
                const ty = vTargetPositions ? vTargetPositions[i3 + 1] : 0;
                const tz = vTargetPositions ? vTargetPositions[i3 + 2] : 0;

                // í©ì–´ì§ˆ ë•ŒëŠ” ì›ë˜ ìœ„ì¹˜ì—ì„œ ì•½ê°„ ë” ë°”ê¹¥ìœ¼ë¡œ ëœë¤í•˜ê²Œ í¼ì§€ë„ë¡ í™•ì¥
                const scatterFactor = 1 + (params.expansion * 0.02) * (1 - easedT);
                const jitter = randomOffsets[i] * 0.5;

                const scatterX = sx * scatterFactor + jitter;
                const scatterY = sy * scatterFactor + Math.sin(time * 3 + randomOffsets[i]) * 0.5;
                const scatterZ = sz * scatterFactor;

                // ìŠ¤ìºí„° ìœ„ì¹˜ì™€ íƒ€ê¹ƒ ìœ„ì¹˜ ì‚¬ì´ë¥¼ ë³´ê°„
                positions[i3]     = scatterX * invT + tx * easedT;
                positions[i3 + 1] = scatterY * invT + ty * easedT;
                positions[i3 + 2] = scatterZ * invT + tz * easedT;
            }
        }


            controls.update();
            composer.render();
            
            // ğŸŒŸ Export ë¡œì§
            if (isExporting) {
                if (capturedFrames < framesToCapture) {
                    frameCountElement.textContent = capturedFrames + 1;
                    
                    if (exportFormat === 'png') {
                        downloadFrame(capturedFrames);
                    } else if (exportFormat === 'gif') {
                        // ğŸŒŸ GIF í”„ë ˆì„ ìº¡ì²˜ (ì‹¤ì œ gif.js í˜¸ì¶œ ë¡œì§ ëŒ€ì‹  ì½˜ì†” ë¡œê·¸)
                        // gif.addFrame(renderer.domElement, {copy: true, delay: 1000/60}); 
                        console.log(`[GIF] Capturing frame ${capturedFrames + 1}`);
                    }
                    capturedFrames++;
                } else {
                    isExporting = false;
                    exportInfoElement.style.display = 'none';
                    if (exportFormat === 'gif') {
                        // gif.render(); // ğŸŒŸ GIF ë Œë”ë§ ì‹œì‘
                        alert("GIF Export ì¤€ë¹„ ì™„ë£Œ. (ì‹¤ì œ ë Œë”ë§ì€ ì™¸ë¶€ ë¼ì´ë¸ŒëŸ¬ë¦¬ í•„ìš”)");
                    } else if (exportFormat === 'png') {
                        alert("PNG Sequence Export ì™„ë£Œ!");
                    }
                }
            }

            stats.end(); // FPS ì¸¡ì • ì¢…ë£Œ
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>